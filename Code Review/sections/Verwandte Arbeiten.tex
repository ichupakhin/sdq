\chapter{Verwandte Arbeiten}
\label{ch:Verwandte Arbeiten}


\section{Extending an Architecture and Code Co-Evolution Approach to Support Existing Software Projects}\label{sec:Extending an Architecture and Code Co-Evolution Approach to Support Existing Software Projects}
Petersen hat in seiner Masterarbeit \cite{petersen2016} den Co-Evolution Approach von Langhammer \cite{langhammer2017} erweitert. Zur Erinnerung, der Co-Evolution-Ansatz wird durch Vitruvius \cite{vitruvius} realisiert. Der Kernpunkt der Masterarbeit war eine Integration von bereits existierenden Projekten in den Co-Evolution-Ansatz \cite{langhammer2017}. Das Problem bei so einer Integration war, dass das zu integrierende Projekt, bestehend aus einem Code und einem Architekturmodell, eine bestimmte Struktur haben muss, um in den Co-Evolution-Ansatz eingebunden werden zu können. Falls es nicht der Fall ist, kann das Projekt nicht integriert werden, weil man keine Korrespondenzen zwischen den Code- und Architekturkomponenten aufbauen kann, was für eine Konsistenzhaltung zwischen den Modellen notwendig ist. Petersen hat eine Lösung des Problems vorgeschlagen. Während der Integration markiert man alle integrierten Teile des Projekts als 'integriert'. Ein Entwickler kann dann an dem Projekt arbeiten. Wenn er neue Teile zu dem Projekt hinzufügt, kommt der Standardmechanismus von Vitruvius zum Einsatz, um die neu erstellten Modelle konsistent zu halten. Wenn aber der Entwickler die als 'integriert' markierten Teile des Projekts ändert oder erweitert, wird der von Petersen implementierte Mechanismus aktiviert. Dieser Mechanismus benachrichtigt dann den Entwickler, welche Teile der Architektur manuell angepasst werden müssen. Manche Typen von Änderungen werden in die Architektur automatisch propagiert und müssen somit nicht manuell durchgeführt werden.
\\
Um die Ergebnisse seiner Masterarbeit zu evaluieren, musste Petersen unter anderem inkrementelle Code-Änderungen zu simulieren. Dafür hat er ein Tool namens Changereplay \cite{changereplay} implementiert. Das Tool basiert auf JGit\cite{jgit} und GumTree\cite{gumtree}. Mit dem Tool kann man ein Commit auslesen, Code-Änderungen extrahieren und in kleine Schritte zerlegen. Als Ergebnis bekommt man eine Liste von Strings. Das erste String-Element in dieser Liste repräsentiert den Code vor dem Commit und das letzte den Code nach dem Commit. Alle Elemente dazwischen repräsentieren den Code in einem Zwischenzustand nach einer atomaren Änderung. Welche Änderung als atomar zählt, wird durch GumTree definiert. Wenn man alle atomaren Änderungen aus der Liste nacheinander auf den Code anwendet, bekommt man den Code in dem Zustand nach dem Commit. 
\\
Falls wir in unserer Bachelorarbeit das Changereplay Tool für eine statische Codeanalyse benutzen würden, stießen wir auf folgendes Problem: Da wir den Code und die Code-Änderungen nur in einer String-Form haben, bekommen wir keine Informationen darüber, an welcher Stelle im Code diese Änderungen stattfinden. Diese Informationen brauchen wir aber, um anschließend die Quellcode-Modelle anhand von den Code-Änderungen inkrementell zu aktualisieren. Man müsste dann zwei Code-Versionen miteinander vergleichen und die Stellen, wo sie sich unterscheiden, manuell ausrechnen. Das würde uns keinen Vorteil bringen, weil man stattdessen zum Beispiel bereits aus dem Git Commit die Zeilennummern von Änderungen erfahren oder mit GumTree die Code-Struktur von zwei Code-Versionen miteinander vergleichen und dadurch die abweichenden Stellen ermitteln könnte. Aus diesem Grund werden wir das Changereplay-Tool in unserer Implementierung nicht benutzen.

%Mit diesen Vorgehensweisen werden wir uns tatsächlich in unserer Bachelorarbeit beschäftigen. Mehr Details dazu sind in dem Kapitel 'Konzeption' zu finden. 

\section{Adaptive Monitoring for Continuous Performance Model Integration}\label{sec:Adaptive Monitoring for Continuous Performance Model Integration}
Dahmane hat in seiner Masterarbeit \cite{dahmane2019} eine Implementierung für das adaptive Monitoring für den Continuous Integration Of Performance Model Ansatz (CIPM) vorgeschlagen. Sein Ansatz versorgt das Performance-Modell (PM) mit Monitoring-Informationen. Bevor Monitoring-Informationen gesammelt werden können, muss der Quellcode instrumentiert werden \cite{wikiCodeInstrumentierung}. Dafür hat Dahmane das VSUM von Vitruvius (Abschnitt \ref{sec:Vitruvius}) um ein Instrumentaion Model (IM) erweitert. Das IM und das Quellcode-Modell werden von Vitruvius konsistent gehalten. IM ermöglicht, basierend auf Quellcode-Änderungen, eine inkrementelle Instrumentierung des Quellcodes. In IM werden Monitoring-Proben gespeichert. Eine Monitoring-Probe enthält einen für die Instrumentierung nötigen Code und Informationen über die Stelle, wo dieser Code im Quellcode hinzugefügt werden muss (Instrumentation Point). Während der Instrumentierung wird eine Kopie von dem Quellcode erstellt und die Monitoring-Proben in diese Kopie eingesetzt. Danach kann der Monitoring-Prozess gestartet werden. Monitoring-Informationen werden in einem Monitoring Record (MR) gespeichert. Ein MR kann Informationen über Reaktionszeit, Anzahl der ausgeführten Schleifeniterationen, Wahrscheinlichkeit einer Sprungvorhersage oder Parameter eines Methodenaufrufes in einer externen Komponente enthalten. Wenn es genug Monitoring-Daten zu einer Monitoring-Probe gesammelt wurden, kann diese Monitoring-Probe deaktiviert werden. Anhand von erstellten MRs kann anschließend PM aktualisiert werden.
\\   
Im Rahmen dieser Bachelorarbeit befassen wir uns mit dem ersten Schritt für den CIPM-Ansatz und zwar mit der Extrahierung  von Code-Änderungen. In der Evaluierung unserer Ergebnisse wollen wir unter anderem zeigen, dass unser implementierte Ansatz im Kontext von CIPM korrekt funktioniert. Für diesen Zweck wollen wir unsere Implementierung an die Implementierung von Dahmane anknüpfen. Auf diese Art können wir das Performance-Modell anhand von Code-Änderungen inkrementell aktualisieren und die Korrektheit des erstellten Performance-Modells überprüfen. 
 
%Dahmane hat sich zwar mit den anderen weiteren Schritten von dem CIPM-Ansatz beschäftigt, diese hängen aber mit dem ersten zusammen. Insbesondere hat Dahmane in seiner Implementierung auch Code-Änderungen simuliert. Allerdings hat er keine Commits ausgelesen, sondern Code-Änderungen per Hand erstellt. Das bedeutet, man wusste im Voraus, was für ein Typ von Änderungen das ist und wo genau diese Änderungen stattfinden. Dahmane hat teilweise die Implementierung von Langhammer \cite{langhammer2017} benutzt. In unserer Arbeit können wir den Code von Dahmane sowie von Langhammer benutzen. Auf diese Art können wir die Funktionalität von unserer Implementierung testen sowie das Zusammenspiel von mehreren implementierten Schritten für den CIPM-Ansatz sehen.  


